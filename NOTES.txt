04/13/2016 - attach hierarchy information to CPP
-do all the attrs stuff -> [DONE] -> that took forever -> that was awful -> ahhhh
-build hierarchy of HRBFs


04/12/2016 - finishing getting HRBF what it needs
-needs joint hierarchy information
	-we can extract relative rotation from matrices
	-we just need to know which matrices go together
	-this likely has to be passed in by MEL
	-we CAN descendants -> get children in MEL
		-so should enforce selecting root. can use list relatives parent to enforce this
		-TODO: write a small hierarchy traversal function in MEL [done]

			listRelatives -c "LeftLeg";

		-this will help us pass hierarchy information to C++
	-how to include this as an attribute though?
		-can we just do this as an attrib array of some kind?
		-clever indexing?
		-could we just do an int array parallel to the matrices?
		-and each item in the array indicates index of parent?
		-we'd be able to get parent transform, which realistically is all we need to compute a full hierarchy in the CPP

	-ok. lesson learned: maya does NOT like you messing with the order of matrices in bind
	-the skin weights for each vertex must be laid out in the same way as listRelatives gets us the matrices -> BOOOOOO
	-need to compute indices of parents based off this ordering! TODO! [DONE]

-ensure that the iterator over points always goes in the same order
	-we'll run some tests

04/08/2016 - getting started with HRBF and HRBF manager
-question: how do we make sure each matrix matches to the right HRBF?
	-do the matrices always come out in the same order?
	-appears to be the case
	-skinning pseudocode:
		-get all the matrices from an iterator
		-look at each point
			-each point has a list of weights -> also in an interator
			-the weights are ordered the same as the matrices from the iterator
		-hopefully this doesn't change in between calls or we'll have some major trouble
-question: how do we extact bone positions from matrices?
	-the transformation itself is an ID
	-the inverse TF matrix is probably where we should do this
-question: how do we extract parent/child info from the matrices?
	-well... there are some "bones" that don't actually have a "next joint" at all
		-see the fingertips
	-so it'd probably be more robust to do this with sampling
	-compute a sampling of joints that are furthest away and use that as a cap

04/06/2016 - fixing DQ, adding HRBF setup
-things to try to fix DQ:
	-try transposing each set of matrices individually -> I think the translation one is right
		-compare side-by-side with Maya's DQ -> ok so I think the matrix access is all fixed
	-try only doing DQ for the local transform and applying the inverse TF as usual

-discovery: with the code as it was at last commit (bug freakout) the translation doesn't do anything on its own! ruh roh!
	-turns out... we weren't building the blended DQ matrix with the right row/column order
	-fixing that makes it do SOMETHING, but it's still wrong
	-something something something affine transform?
	-should probably try the DQ only local transforms thing?
	-do we need to only DQ the local transforms though? [WRONG]
-problem atm seems to be in construction of translation quaternion

03/29/2016 - Setting up HRBFs
-we're going to need a HRBF manager class
-and individual HRBF classes
-all using Maya's underlying math, preferably
-we'll initialize these in deform:
	-on first deform, check if the HRBF manager is null
	-if so, build the HRBF using the data passed in
-can we tie skin weight changes to skin weight changes?
-or can we add a button that calls a method in here to recompute HRBFs?

03/29/2016 - LBS vs. Dual Quaternion
-so the example code implements LBS
-splitting matrix into translate/rotate components:
	-assuming maya rotates and then translates, easy as just accessing portions
-need way to make quat from 3x3 rotaiton -> http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
-adam's slides are really good, very implementation rich
	-breaks down to:
	-get rotation quat (more or less a 4-tuple)
	-get translation quat from translation vector, rotation quat -> dual quaternion coupling
	-make matrix with rotation part based on rotation quat
	-compute translation vector from translation and rotation quat -> dual quat coupling 
-how to blend dual quats without an explicit representation?
-do you literally just multiply both quaternions by the weight? lol

03/29/2016 - Setting up the MEL [beta: done]


-original PROC provided with plugin
proc connectJointCluster( string $j, int $i )
{
    if ( !objExists( $j+".lockInfluenceWeights" ) )
    {
        select -r $j;
        addAttr -sn "liw" -ln "lockInfluenceWeights" -at "bool";
    }
    connectAttr ($j+".liw") ("HRBFSkinCluster1.lockWeights["+$i+"]");
    connectAttr ($j+".worldMatrix[0]") ("HRBFSkinCluster1.matrix["+$i+"]");
    connectAttr ($j+".objectColorRGB") ("HRBFSkinCluster1.influenceColor["+$i+"]");
	float $m[] = `getAttr ($j+".wim")`;
	setAttr ("HRBFSkinCluster1.bindPreMatrix["+$i+"]") -type "matrix" $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
}

joint -p 1 0 1 ;
joint -p 0 0 0 ; // auto-attaches to last selected joint
joint -e -zso -oj xyz -sao yup joint1; // reorient joint 1
joint -p 1 0 -1 ;
joint -e -zso -oj xyz -sao yup joint2; // reorient joint 2
polyTorus -r 1 -sr 0.5 -tw 0 -sx 50 -sy 50 -ax 0 1 0 -cuv 1 -ch 1;
deformer -type "HRBFSkinCluster";
//setAttr HRBFSkinCluster1.useComponentsMatrix 1; // obsolete
connectJointCluster( "joint1", 0 ); // link joint to skin cluster. TODO: have this take in a string for skin cluster name
connectJointCluster( "joint2", 1 ); // link joint to skin cluster
connectJointCluster( "joint3", 2 ); // link joint to skin cluster
skinCluster -e -maximumInfluences 3 HRBFSkinCluster1;	// forces computation of default weights. we'll import a weight map instead

	polyTorus -r 1 -sr 0.5 -tw 0 -sx 50 -sy 50 -ax 0 1 0 -cuv 1 -ch 1;
	string $clusterStr[] = `deformer -type "basicSkinCluster"`;
	print($clusterStr);

-this little sequence of commands will make a torus, make a skin cluster attached, and hand you the name of said cluster

	ls -sl

-this will list the selected stuff in order of selection. you can do:
	
	string $selectedNodes[] = `ls -sl`;
	print($selectedNodes[0]);

	string $selectedNodes[] = `ls -sl`;
	for ($i = 0; $i < size($selectedNodes); $i++) {
	    print("type: " + `objectType $selectedNodes[$i]`);
	    print(" name: ");
	    print($selectedNodes[$i]);
	    print("\n");    
	}

-this is how you walk over the joints of a skeleton

	string $rels[] = `listRelatives -ad "joint1"`;
	print($rels);

-the workflow we're going through will be something like:
	-select mesh
	-select skeleton
	-run script to attach bones to skin -> eventually, will be tied into UI
	-import skin weights



**********************************************************************************
MAYA INTERACTION NOTES
-ok. skinning is a type of DEFORMER using SKIN CLUSTERS
-with all DEFORMERS you can set the envelope, which is like how much the deformer is actually applied
	-this is in deformer attributes
	-presumably this is what the maya documentation means by percent command
-

********************************************************************************
-we'll need a main -> doyyyy
-we'll need a gl viewer wrapper -> to be reused a lot later? -> look at GL code
-we'll need a scene to manage drawables
-we'll need a drawable subclass
	-GL buffers
	-get vertex buffer
	-get index buffer
	-get normal buffer

-we'll include a dedicated mesh drawable class
-HRBF draw will be a subclass of this
	-but HRBF itself will have to be a separate class

-HRBF segment will voxelize and push all the cubes to GL? is that crazy?
-maybe we'll do points for now... less taxing on the GPU?

TODO
-set up a starter repo using the 563 GL basecode (skeleton)
	-get GLFW working
	-get a basic drawable cube class working -> refer back to 460 for classing, subclassing
-get a basic mesh loader going
-think about how to visualize the HRBF
	-right now I'm thinking voxels